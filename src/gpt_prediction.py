# -*- coding: utf-8 -*-
"""gpt_prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-NzxzQsWWb7Ys1XLoRqyRKFkW_RuoDcF
"""

# !pip install -q openai
# !pip install transformers
# !pip install datasets

import json
import pandas as pd
import numpy as np
import zipfile
from tqdm import tqdm
import time
import openai

from transformers import AutoModelForSequenceClassification
from transformers import AutoTokenizer
from transformers import pipeline

from transformers import TrainingArguments, Trainer
import numpy as np

from datasets.dataset_dict import DatasetDict
from datasets import Dataset
import pickle

# from google.colab import drive
# drive.mount('/content/drive')

# path = "/content/drive/My Drive/CS224N/final_phase2/"
token = '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'

data = pd.read_csv("../Datasets/raw/mbti_tweets.csv")
# data

def zero_shot_prediction(text, token):
  openai.api_key = token
  samples = []

  messages = [ {"role": "system", "content":
            "You are a intelligent assistant."} ]


  try:
    prompt = f'''Your task is to predict the possible personality of the writer of a text which is delimited by three backticks.
                There are four distinct classifications for this task.
                classification 1 classes: "Extrovert" and "Introvert"
                classification 1 labels: "E" and "I" respectively
                classification 2 classes: "Sensors" and "Intuitives"
                classification 2 labels: "S" and "N" respectively
                classification 3 classes: "Thinkers" and "Feelers"
                classification 3 labels: "T" and "F" respectively
                classification 4 classes: "Judgers" and "Perceivers"
                classification 4 labels: "J" and "P" respectively

                only give the predicted label for each classification. It means that you need to give 4 answers. Concatinate the labels with eachother in the above order.
                give only one answer for each classification. be carful about the order of your answer, it is important.
                For example this could be two sample answers (learn the format of the output, do not copy):
                sample answer1:
                  "ENTJ"
                sample answer2:
                  "INFJ"

                text: ```{text}```'''



    message = prompt
    if message:
      messages.append(
        {"role": "user", "content": message},
      )
      chat = openai.ChatCompletion.create(
        model="gpt-3.5-turbo", messages=messages
      )
    reply = chat.choices[0].message.content
    # print(reply)

    samples.append(reply)
    messages.append({"role": "assistant", "content": reply})
  except Exception as e:
    print(e)
    samples.append("error")
    # print("There is an error in : ", i)

  return samples

def get_data(index):
  text = ""
  for i in range(10):
    try:
      text += f"tweet {i+1}: " + data.iloc[index][f"tweet_{i}"] + "\n"
    except:
      continue
  return text, data.iloc[index]["type"]

# text, label = get_data(2)
# print("actual label: ", label)
# zero_shot_prediction(text, token)

def few_shot_prediction(sample_text1, sample_label1, sample_text2, sample_label2, text, token):
  openai.api_key = token
  samples = []

  messages = [ {"role": "system", "content":
            "You are a intelligent assistant."} ]


  try:
    prompt = f'''Your task is to predict the possible personality of the writer of a text which is delimited by three backticks.
                There are four distinct classifications for this task.
                classification 1 classes: "Extrovert" and "Introvert"
                classification 1 labels: "E" and "I" respectively
                classification 2 classes: "Sensors" and "Intuitives"
                classification 2 labels: "S" and "N" respectively
                classification 3 classes: "Thinkers" and "Feelers"
                classification 3 labels: "T" and "F" respectively
                classification 4 classes: "Judgers" and "Perceivers"
                classification 4 labels: "J" and "P" respectively

                only give the predicted label for each classification. It means that you need to give 4 answers. Concatinate the labels with eachother in the above order.
                give only one answer for each classification. be carful about the order of your answer, it is important.
                For example this could be two samples (pay additional attention to the format of the labels and learn it, do not copy):
                sample 1:
                  tweet: "{sample_text1}"
                  label: "{sample_label1}"
                sample 2:
                  tweet: "{sample_text2}"
                  label: "{sample_label2}"

                text: ```{text}```'''


    message = prompt
    if message:
      messages.append(
        {"role": "user", "content": message},
      )
      chat = openai.ChatCompletion.create(
        model="gpt-3.5-turbo", messages=messages
      )
    reply = chat.choices[0].message.content
    # print(reply)

    samples.append(reply)
    messages.append({"role": "assistant", "content": reply})
  except Exception as e:
    print(e)
    samples.append("error")

  return samples

# text, label = get_data(2)
# print("actual label: ", label)
# few_shot_prediction(get_data(0)[0], get_data(0)[1], get_data(1)[0], get_data(1)[1], text, token)

def gpt_prediction_zero_shot(row):
  label = row['type']
  text = ""
  for i in range(10):
    try:
      text += f"tweet {i+1}: " + row[f"tweet_{i}"] + "\n"
    except:
      continue
  pred = zero_shot_prediction(text, token)
  return pred

zero_shot_pred = []
for i in tqdm(range(100)):
  if i % 3 == 0 and i != 0:
    time.sleep(61)
  row = data.iloc[i]
  zero_shot_pred.append(gpt_prediction_zero_shot(row)[0])

count = 0
for i in range(100):
  label = data.iloc[i]["type"]
  pred = zero_shot_pred[i]
  if label == pred:
    count += 1
print(f"The baseline accuracy for gpt3 with zero-shot learning is {count}%")

few_shot_pred = []
for i in tqdm(range(100)):
  if i % 3 == 0 and i != 0:
    time.sleep(61)

  row = data.iloc[i]
  row1 = data.iloc[i+100]
  row2 = data.iloc[i+200]

  label = row['type']
  label1 = row1['type']
  label2 = row2['type']

  text = ""
  text1 = ""
  text2 = ""
  for i in range(10):
    try:
      text += f"tweet {i+1}: " + row[f"tweet_{i}"] + "\n"
      text1 += f"tweet {i+1}: " + row1[f"tweet_{i}"] + "\n"
      text2 += f"tweet {i+1}: " + row2[f"tweet_{i}"] + "\n"
    except:
      continue
  pred = few_shot_prediction(text1, label1, text2, label2, text, token)
  few_shot_pred.append(pred[0])

count = 0
for i in range(100):
  label = data.iloc[i]["type"]
  pred = few_shot_pred[i]
  if label == pred:
    count += 1
print(f"The baseline accuracy for gpt3 with few-shot learning is {count}%")

